{
    "collab_server" : "",
    "contents" : "##plot research space\n#frebrua\n#remember to source config.R and createResearchSpace.R\n#config(cl='ucsd')\n#' @export\ncreate_rs_ucsd <- function()\n{\n\tfile_rdata<- \"New_rs_sim_pr_1971_2010_n_-1_aw_0_jf_0_awjf_0.1_min_prod_0.RData\"\n\tmean_degree <- 10\n\t#for(pl_seed in c(113,155,799,19,70,72)) to make a search for the most similar to the SCIMago 72\n\t#\tplot_rs_final(file_rs = file_rdata, mean_degree = mean_degree, mst = mst, pl_seed = pl_seed, mode=\"max\")\n\t\tplot_map(file_rs = file_rdata, mean_degree = mean_degree, mst = mst, pl_seed = 72, mode=\"max\") #pc lab utfsm seed 72 \n}\n\n#config(cl='scimago')\n#' @export\ncreate_rs_simago <- function()\n{\n\tfile_rdata<- \"New_rs_sim_pr_1971_2010_n_-1_aw_0_jf_0_awjf_0.1_min_prod_0.RData\"\n\tmean_degree <- 10\n\tplot_map(file_rs = file_rdata, mean_degree = mean_degree, mst = mst, pl_seed = 69, v_min_size = 10, cex=1, mode=\"max\")\n}\n\n\n#mode is the mode that you want to use in the graph\n#' @export\nplot_map <- function(file_rs, mean_degree=5, mode=\"max\", mst=TRUE, pl_seed=69, prop_to_lab=0.2, cex=1, pl=TRUE, pl_mst=FALSE, title='', subtitle='Subt', v_min_size=10, v_col='orig')\n{\n\ttitle<- toupper(mode)\n\tnodes <- load_taxonomy(\"scimago\")\n\tlibrary(\"igraph\")\n\tpath_rs <- \"/Users/mguevara/Dropbox/doctorado/MIT_PROJECT/TESIS_RESEARCH_SPACE/DATA/RESEARCH_SPACE/SCIMAGO/RESEARCH\\ SPACE\\ OUTPUT\" #HARD CODED\n\tpath_rs <- \"/Users/mguevara/Dropbox/doctorado/MIT_PROJECT/TESIS_RESEARCH_SPACE/DATA/RESEARCH_SPACE/UCSD/RESEARCH\\ SPACE\\ OUTPUT\" #HARD CODED\n\tload(file.path(path_rs, file_rs)) #load complete information of the research space wanted all variables are rs_\n\t#adj <- dis_categories(pantheon)\n\t#pheatmap(adj, cluster_rows=FALSE, cluster_cols=FALSE)\n\t#load(file_rs)\n\tadj_orig <- rs_adj\n\t#diag(adj_orig) <- 0\n\tadj_clean <- adj_orig\n\tdiag(adj_clean) <-0\n\t#cleanning NA\n\tadj_clean[is.na(adj_clean)] <- 0\n\t\n\tcat_not_connected <- rownames(adj_clean)[rowSums(adj_clean) == 0 | colSums(adj_clean) == 0]\n\tprint(paste(\"Number of categories not conected\", length(cat_not_connected)))\n\t\n\tcat_connected <- rownames(adj_clean)[rowSums(adj_clean) != 0 & colSums(adj_clean) != 0] #note that in the case of probability the Min of upper triangular and lower triangular is taken, so connection in both upper and lower triangle of the matrix is required!!!\n\t\n\t#cleanning un connected categories\n\tadj_cc <- adj_orig[cat_connected, cat_connected]\n\tadj_cc[is.na(adj_cc)] <- 0 #in case NAs\n\t#creating full graph for union future process \n\t#adj_full <-  (adj_cc-min(adj_cc,na.rm=TRUE))/(max(adj_cc, na.rm=TRUE)-min(adj_cc, na.rm=TRUE)) #normalizing between zero and one\n\tadj_full <- adj_cc\n\tg_full <- graph.adjacency(adjmatrix = adj_full, mode = mode, weighted = TRUE, diag = FALSE) #note minimum because the min probability ORIGINAL\n\t#g_full <- graph.adjacency(adjmatrix = adj_full, mode = \"directed\", weighted = TRUE, diag = FALSE) #modified to be directed\n\t\n\t\tprint(\"Computing minimum spnanning tree\")\n\t\t#normalize similarities\n\t\t#dist_matrix <- 1 - (adj_cc-min(adj_cc,na.rm=TRUE))/(max(adj_cc, na.rm=TRUE)-min(adj_cc, na.rm=TRUE)) #normalizing between zero and one\n\t\tdist_matrix <- 1 - (adj_cc)/(max(adj_cc, na.rm=TRUE)) #normalizing per le maximum, numerator should not has values of zero!\n\t\t#MST must use the DISTANCE matrix NOT the similarities!!!!!\n\t  mode_mst<- mode\n\t\tif(mode==\"max\")\n\t\t\tmode_mst<- \"min\"\n\t\tif(mode==\"min\")\n\t\t\tmode_mst <- \"max\"\n\t\tg_mst <-  graph.adjacency(adjmatrix = dist_matrix, mode = mode_mst, weighted = TRUE, diag = FALSE) #max is the worst case ORIGINAL\n\t\t#g_mst <-  graph.adjacency(adjmatrix = dist_matrix, mode = \"directed\", weighted = TRUE, diag = FALSE) #max is the worst case\n\t\t#g_mst <- simplify(g_mst, remove.multiple = TRUE, remove.loops = TRUE, edge.attr.comb = list(weight=\"min\", \"ignore\")) #taking the minimum of the probability\n\t\t#E(g_mst)$sim <- -1*(E(g_mst)$weight -1)\n\t\t#g_original <<- g_mst\n\t\t#g_mst=delete.edges(g_mst, which(E(g_mst)$weight <=1)) # here's my condition.\n\t\t\n\t\tg_mst <- minimum.spanning.tree(g_mst)\n\t\t\n\t\tif(pl_mst==TRUE)\n\t\t{\n\t\t\tmain <- paste( title, \"\\n Minimum Spanning Tree\")\n\t\t\tpar(mfrow=c(1,2))\n\t\t\tplot_graph_smart_2(g_mst, main=main, lay = 'fr', v_label = 'no', v_size='degree', cex = cex, v_min_size=v_min_size) #force directed\n\t\t\tplot_graph_smart_2(g_mst, main=main, lay = 'rt', v_label = 'no', v_size='degree', cex = cex, v_min_size=v_min_size) #tree\n\t\t\tpar(mfrow=c(1,1))\n\t\t\tplot_graph_smart_2(g_mst, main=main, lay = 'rt', v_label = 'com', v_size=2, cex = cex, v_min_size=v_min_size) #tree\n\t\t}\n\t\t\n\t\t\n\t\t#flagging edges of Minimum ST for future combination\n\t\tE(g_mst)$mst <- 1\n\t \n\t\n\t#######THERSHOLD up to certain mean degree (ideally 4)\n\n\t\tprint(\"Computing threshold graph\")\n\t\tfilter <- min(rs_adj) #initial filter \n\t\t#if(rs_sim=='n') increment <- 1\n\t\t#if(rs_sim=='pr') increment <- 0.001 \n\t\t\n\t\tincrement <- 0.001\n\t\tdegree_rs <- mean_degree + 1 #to go into the loop\n\t\tadj_th <- adj_cc\n\t\t#adj_th <-  (adj_th-min(adj_th,na.rm=TRUE))/(max(adj_th, na.rm=TRUE)-min(adj_th, na.rm=TRUE)) #normalizing between zero and one\n\t\t\n\t\twhile(degree_rs > mean_degree)\n\t\t#while(kk > kkk )\n\t\t{\n\t\t\t#print(\"here!!\")\n\t\t\tadj_th[adj_th < filter] <- 0\n\t\t\tcat_non_zero <- rownames(adj_th)[rowSums(adj_th)!=0]\n\t\t\tadj_th <- adj_th[cat_non_zero, cat_non_zero]\n\t\t\t#print(adj_th)\n\t\t\tg <- graph.adjacency(adjmatrix = adj_th, mode = mode, weighted = TRUE, diag = FALSE) #note minimum because the min probability\n\t\t\t#g <- graph.adjacency(adjmatrix = adj_th, mode = \"directed\", weighted = TRUE, diag = FALSE) #note mi\n\t\t\tdegree_rs <- mean(degree(g))\n\t\t\t#print(paste(\"Degree_RS\", degree_rs))\n\t\t\tfilter <- filter + increment\n\t\t}\n\t\t#print(mean(degree(g)))\n\t\t#print(\"Degreeeeee\")\n\t\t#print(degree(g))\n\t\t#print(max(degree(g),na.rm=TRUE))\n\t\t\n\t\t#print(V(g)$size)\n\t\t#fc <- fastgreedy.community(g); colors <- rainbow(max(membership(fc)))\n\t\t#V(g)$color = colors[membership(fc)]\n\t\t#V(g)$membership <- fc$membership\n\t\t\n\t\t#if(length(V(g)) < (prop_to_lab * length(rownames(nodes))) )\n\t\t#\tV(g)$label = as.character(nodes$subd_name[match(V(g)$name, nodes$Id)]) #watch out with the name of the column!!\n\t\t#else\n\t\t#{\n\t\t#print(\"Filtering labels...\")\n\t\t#\tnod_max_com <- get_max_com(g)  #get the nodes with max degree per community\n\t\t#print(nod_max_com)\n\t\t#\tV(g)$label <- ''\n\t\t#V(g)$label[V(g)$name %in% nod_max_com] <- as.character(nodes$subd_name[match(nod_max_com, nodes$Id)])\n\t\t#\tnodes_to_label <- V(g)$name[V(g)$name %in% nod_max_com] #to get the order of iGraph\n\t\t#\tV(g)$label[V(g)$name %in% nod_max_com] <- as.character(nodes$subd_name[match(nodes_to_label, nodes$Id)])\n\t\t#}\n\t\t# set.seed(pl_seed)\n\t\t# g$layout <- layout.fruchterman.reingold(g)\n\t\t\n\t\t\t#title_th <- paste(\"Only threshold\" , title)\n\t\t\t#par(mfrow=c(1,1))\n\t\t\t#plot_graph_smart_2(g, main = title_th, sub_add = paste(subtitle, \"Seed plot: \",\n\t\t\t#\tpl_seed, '| Threshold for links: ', filter-increment),lay = \"fr\", cex = cex, v_min_size=v_min_size)\n\t\tg_th <- g\n\t\t#flagging edges from threshold graph to future combination\n\t\tE(g_th)$threshold <- 1\n\n\t\n\t#MERGING GRAPHS.....\n\t#E(g)$weight <- E(g)$weight/max(E(g)$weight, na.rm=TRUE) #NORMALIZING BETWEEN 0 AND 1\n\t#first Full + MST\n\tprint(\"Merging graphs\")\n\tg <- graph.union(g_full, g_mst, g_th) #note union is computed by NAME, not by ID, so it is correct to our propose\n\tprint(\"Union created\")\n\tE(g)$weight <- E(g)$weight_1\n\tE(g)$mst[is.na(E(g)$mst)] <- 0\n\tE(g)$threshold[is.na(E(g)$threshold)] <- 0\n\tE(g)$used <- E(g)$mst + E(g)$threshold #union\n\t#print(\"Deliting edges ...\")\n\t#g <- delete.edges(g, E(g)[E(g)$used < 1]) #podding edges that are not in mst and not in Threshold graph MOVED TO EACH FUNCTION\n\t#E(g)$weight_used[E(g)$used >= 1] <- E(g)$weight[E(g)$used >= 1] #storing weights of edges that are the ones to apply the filter\n\t\n\t#print(\"Edges_deleted...\")\n\t#E(g)$weight[!is.na(E(g)$sim)] <- E(g)$sim #adding mst weights in mst they are in sim not in weight since in weight_1 they are distances.\n\t#E(g)$weight[is.na(E(g)$weight)] <- E(g)$weight_2[is.na(E(g)$weight)]\n\t#E(g)$weight <- E(g)$sim #adding mst weights in mst they are in sim not in weight since in weight_1 they are distances.\n\t#E(g)$weight[is.na(E(g)$weight)] <- E(g)$weight_2[is.na(E(g)$weight)]\n\t\n\t\n\n\t\tlab='com'\n\t\n\t\tif(length(V(g)) < (prop_to_lab * length(rownames(nodes))) )\n\t\t\tlab='all'\n\t\ttitle= paste(\"MST+Threshold \",title, \"\\nMean degree:\", mean_degree, \"SEED\", pl_seed) \n\t\tpar(mfrow=c(1,1))\n\t\t#original community over all the graph before deletion\n\t\tfc <- infomap.community(g); colors <- rainbow(length(fc))\n\t\tV(g)$color <- colors[membership(fc)]\n\t\t\n\t\tprint(\"Ploting threshold graph\")\n\t\tg_to_plot <- delete.edges(g, E(g)[E(g)$used < 1])\n\t\tplot_graph_smart_2(g_to_plot, main = title, sub_add = paste(subtitle, \"Seed plot: \",\n\t\t\tpl_seed, '| Threshold for links: ', filter-increment),lay = \"fr\", v_label=lab, cex = cex, v_min_size=v_min_size, v_col='orig', pdf_w = FALSE, file_name=paste('Research Space ', taxo, ' - ClColors', sep=''), pl_seed=pl_seed ) #v_col color based on community com, original = orig, NULL for the community over all the matrix\n\t\t#ploting with other colors\n\t\tplot_graph_smart_2(g_to_plot, main = title, sub_add = paste(subtitle, \"Seed plot: \",\n\t\t\tpl_seed, '| Threshold for links: ', filter-increment),lay = \"fr\", v_label=lab, cex = cex, v_min_size=v_min_size, v_col='com', pdf_w = FALSE, file_name=paste('Research Space ', taxo, ' - ComColors', sep=''), pl_seed=pl_seed ) #v_col color based on community com, original = orig, NULL for the community over all the matrix\n\t\t\n\t\t#par(mfrow=c(1,2))\n\t\t#plot_graph_smart_2(g_to_plot, main = paste('Research Space in', taxo, 'classification'), sub = paste(\"Original Taxonomy Colors \\n Communities:\",length(unique(nodes$color))),lay = \"fr\", v_label='no', v_col='orig', cex = cex, v_min_size=v_min_size)\n\t\t#plot_graph_smart_2(g_to_plot, main = paste('Research Space in', taxo, 'classification'), sub='Autodetected Community Colors Assigned', lay = \"fr\", v_label='no', v_col='com', cex = cex, v_min_size=v_min_size)\n\n\t\n\tg_merge_copy <<- g\n\t\n\treturn(g)\n}\n\n\n##ploting graphs with smart labeling and colors\n#sub_add add text to the default sub or to the sub parameter\n#sub subtitle to plot\n#main, main title of the plot\n#g the graph to plot\n#cex a factor to scale all the things in the plot\n#pl_seed the seed to use in the plot\n#lay the layout to use, a mnemonic fr or drl or cir\n#' @export\nplot_graph_smart_2 <- function(g, main='', sub=NULL, sub_add='', cex=1, pl_seed=\"69\", lay='fr', v_label='com', v_size='degree', v_col='com', v_min_size=10, pdf_w=FALSE, file_name=NULL)\n{\n\tnodes = scimago_nodes\n\t######GRAPH PROPERTIES\n\tset.seed(pl_seed)\n\tif(lay=='fr') #force directed\n\t\tg$layout <- layout.fruchterman.reingold(g)\n\tif(lay=='drl')\n\t\tg$layout <- layout.drl(g)\n\tif(lay=='rt') #tree oriented \n\t\tg$layout <- layout.reingold.tilford(g)\n\tif(lay=='sph') #sphere\n\t\tg$layout <- layout.sphere(g)\n\t#fc <- fastgreedy.community(g, weights = NULL); colors <- rainbow(length(fc))\n\tprint(\"Detecting communities...\")\n\t#fc <- fastgreedy.community(g); colors <- rainbow(length(fc))\n\tfc <- infomap.community(g); colors <- rainbow(length(fc))\n\tprint(\"Degree computing...\")\n\tmean_degree <- trunc(mean(degree(g)))\n\tsub_default <- paste( 'Number of nodes: ', length(V(g)), '/', nrow(nodes), '  | Mean degree: ', mean_degree, ' | Detected communities: ', length(fc))\n\t\n\tif(is.null(sub))\n\t\tsub <-\tsub_default\n\t\n\t#adding sub_add to the subtitle \n\tif(!is.null(sub_add))\n\t\tsub <- paste(sub_add, '\\n', sub)\n\tV(g)$membership <- fc$membership\n\t\n\t######## VERTICES PROPERTIES\n\tprint(\"labeling...in\")\n\tif(v_label =='com')\n\t{\n\t\t#g_mst_copy<<- g_mst\n\t\tnod_max_com <- get_max_com(g)  #get the nodes with max degree per community\n\t\t#print(nod_max_com)\n\t\tV(g)$label <- ''\n\t\tnodes_to_label <- V(g)$name[V(g)$name %in% nod_max_com] #to get the order of iGraph\n\t\tV(g)$label[V(g)$name %in% nod_max_com] <- as.character(nodes$subd_name[match(nodes_to_label, nodes$Id)])\n\t\t#V(g)$label = as.character(nodes$subd_name[match(V(g)$name, nodes$Id)])\n\t}\n\tif(v_label == 'all')\n\t\tV(g)$label = as.character(nodes$subd_name[match(V(g)$name, nodes$Id)])\n\tif(v_label == 'no')\n\t\tV(g)$label <- ''\n\t\n\tprint(\"Coloring .... in\")\n\t#color\n\tif(v_col == 'com')\n\t\tV(g)$color <- colors[membership(fc)]\n\tif(v_col == 'orig')\n\t\tV(g)$color <- as.character(nodes$color[match(V(g)$name, nodes$Id)]) \n\t\n\tsub <- paste(sub, '\\n Number of full communities:', length(unique(V(g)$color)))\n\t#size\n\tprint(\"Sizing Nodes...\")\n\tif(is.numeric(v_size)==TRUE)\n\t\tV(g)$size <- v_size\n\tif(v_size=='degree')\n\t\tV(g)$size <- ((degree(g)+v_min_size)/max(degree(g))) * v_min_size\n\tif(v_size == 'orig')\n\t{\n\t\tV(g)$size <- as.numeric(nodes$size[match(V(g)$name, nodes$Id)]) \n\t\tV(g)$size <- (V(g)$size/max(V(g)$size)) *5\n\t}\n\t\n\t#EDGES PROPERTIES\n\tE(g)$arrow.size=0.1\n\tE(g)$curved <- TRUE\n\tE(g)$color <- 'lightgray'\n\t#edge.label.color=\"gray\",\n\t\n\tprint(\"Plotting Graph....in \")\n\t#id <- tkplot(g)\n\t#tkconfigure(igraph:::.tkplot.get(id)$canvas, \"bg\"=\"black\")\n\tpar(lend = 1)           # square line ends for the color legend\n\t#areas_df <- subset(nodes, select=c('Discipline','color'))\n\tnodes[\"Discipline\"] <- nodes$area_name #HARDCODED!\n\tareas_df <- subset(nodes, select=c('Discipline','color'))\n\tareas_df <-unique(areas_df)\n\tareas_df$color <- factor(areas_df$color)\n\t\n\tareas_df$Discipline <- factor(areas_df$Discipline)\n\t\n\t#legend = c(paste(\"Inactive\", num_ina), paste(\"Undeveloped\", num_und), paste(\"Growing\", num_grw), paste(\"Developed\", num_dev), paste(\"Opportunity\", num_rcm)) # category labels \n\t#deleted rs_plot\n\t plot.igraph(g, \n\t\tvertex.label.cex=0.1*cex, \n\t\tmain= list(main, cex=1*cex),\n\t\tvertex.label.font=0, \n\t\tvertex.label.family='Helvetica', \n\t\tvertex.label.color='black', \n\t\tedge.label.cex=0.6*cex,\n\t\tedge.label.family=\"Helvetica\",\n\t\tsub=list(sub,\tcex=0.8*cex),\n\t\tasp=FALSE\n\t)\n\t# legend(\"bottomleft\",      # location of the legend on the heatmap plot\n\t# \tlegend = as.vector(areas_df$Discipline),\n\t# \tpch=19, merge=FALSE,\n\t# \tpt.bg = as.vector(areas_df$color),\n\t# \tcol = as.vector(areas_df$color),\n\t# \t#lty= NA,             # line style\n\t# \tlwd = 1,           # line width\n\t# \tpt.cex = 0.1*cex,\n\t# \tbox.col = \"lightgrey\",\n\t# \t#fill = \"white\",\n\t# \tcex= 1*cex\n\t# )\n\tprint(\"Should have printed...\")\n\t\n\t#EXPORTING PDF file\n\tif(pdf_w ==TRUE)\n\t{\n\t\tdev_file_name <- file.path(path_rs,'RESEARCH SPACE OUTPUT', paste(file_name,'.pdf', sep=''))\n\t\t#dev.print(pdf, file=dev_file_name, widht=6, height=3 );\n\t\tpdf(dev_file_name, width=16, height=12, family='Helvetica', pointsize=8)\n\t\tplot.igraph(g, \n\t\t\tvertex.label.cex=1.1*cex, \n\t\t#\tmain= list(main, cex=1*cex),\n\t\t\tvertex.label.font=0, \n\t\t\tvertex.label.family='Helvetica', \n\t\t\tvertex.label.color='black', \n\t\t\tedge.label.cex=0.6*cex,\n\t\t\tedge.label.family=\"Helvetica\",\n\t\t\t#edge.width=0.1,\n\t\t#\tsub=list(sub,\tcex=0.8*cex),\n\t\t\tasp=FALSE\n\t\t)\n\t\tlegend(\"bottomleft\",      # location of the legend on the heatmap plot\n\t\t\tlegend = as.vector(areas_df$Discipline),\n\t\t\tpch=19, merge=FALSE,\n\t\t\tpt.bg = 'black',\n\t\t\tcol = as.vector(areas_df$color),\n\t\t\t#lty= NA,             # line style\n\t\t\tlwd = 1,           # line width\n\t\t\tpt.cex = 3*cex,\n\t\t\tbox.col = \"lightgrey\",\n\t\t\t#fill = \"white\",\n\t\t\tcex= 1.5*cex\n\t\t)\n\t\t\n\t\tdev.off()\n\t}\n\trs <- g\n\t#exporting to an R object to use it for overlays and others\n\t#save(rs, rs_plot, file = file.path(path_rs,'RESEARCH SPACE OUTPUT', paste('RS_iGRAPH_', taxo, '.RData', sep='')))\n}\n\n\n#get a vector of nodes with max degree value inside each community\n# graph with membership\n# n_com_max number of maximum values per category, in case they are equal max values\n#' @export\nget_max_com <- function(g, n_com_max=1, n_com)\n{\n\tV(g)$degree <- degree(g)\n\t#getting betweenness centrality\n\t#g_lcc <- g\n\t\n\t#\tdecompose.graph(g)\n\t#g_lcc <- g_lcc[[1]] #largest connected component\n\t#print(E(g_lcc)$weight==0)\n\t#V(g_lcc)$betweenness <- betweenness(g_lcc, directed = FALSE)\n\t#E(g_lcc)[E(g_lcc)$weight<=0] <- NULL\n\t#E(g_lcc)[is.na(E(g_lcc)$weight)] <- NULL\n\t#V(g)$betweenness[V(g_lcc)$name] <- V(g_lcc)$betweenness\n\t\n\tV(g)$betweenness <- betweenness(g)\n\t\n\tif(is.null(V(g)$membership))\n\t{\n\t\t#fc <- fastgreedy.community(g)\n\t\tfc <- infomap.community(g)\n\t\tV(g)$membership <- fc$membership\n\t}\n\t\n\tcommunities <- unique(V(g)$membership)\n\tmax_total <- vector()\n\t#print(communities)\n\tfor(com in communities)\n\t{\n\t\t#print(paste(\"comm\", com))\n\t\tmax_deg <- sort(V(g)$degree[V(g)$membership==com ], decreasing=TRUE)\n\t\tmax_betw <- sort(V(g)$betweenness[V(g)$membership==com], decreasing = TRUE)\n\t\t\n\t\tn_max <- as.integer(log(length(max_deg), base=2))  #maximum nodes to label as a function of log base 2 \n\t\t\n\t\tmax_com <- V(g)$name[V(g)$membership==com & V(g)$degree > max_deg[n_max]]\t\n\t\tmax_com <- unique(c(max_com, V(g)$name[V(g)$membership==com & V(g)$betweenness > max_betw[n_max]]))\n\t\t\n\t\t#if(length(max_com) > n_com_max) #avoiding too much max in the same community\n\t\t#max_com <- max_com[1:n_com_max]\n\t\t\n\t\tif(length(max_com)==0 && length(max_deg) > 1) #in case no one node has been labaled in the community\n\t\t{\n\t\t\tnodes_com <- V(g)$name[V(g)$membership==com]\t\n\t\t\tmax_com <- nodes_com[trunc(length(nodes_com)/2)]\n\t\t}\n\t\t\n\t\tmax_total <- c(max_total, max_com)\n\t}\n\t\n\treturn(max_total)\n}\n",
    "created" : 1506695942194.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2592141524",
    "id" : "8623F1AB",
    "lastKnownWriteTime" : 1507212501,
    "last_content_update" : 1507212501376,
    "path" : "~/Dropbox/doctorado/MIT_PROJECT/TESIS_RESEARCH_SPACE/codes/rescinnet/R/PLOTRSpace.R",
    "project_path" : "R/PLOTRSpace.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}