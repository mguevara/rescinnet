{
    "contents" : "#evaluates prediction by using density idea of developed and underdeveloped\n#config(cl=\"ucsd\")\noverlay_data_2 <- function(n=1, what_eval='share', init=2007, end=2012, by=3, pl=FALSE, min_prod=1, agg_fun=sum, list_prod=NaN, min_to_grw =-1, min_to_dev=-1, pl_min_dens=0.15, pl_node_sc=2.5, pl_min_size=0.7, pl_num_lab = 5, cum=FALSE )\n{\n  #n number of sample to conduct the analysis. n=-1 implies over all the producers\n  #init initial year to take the data\n  #end final year to take the data\n  #by number of years to split the data in between init and end\n  #pl true or false if you want to generete an overlay map for each producer\n  #min_prod number of publications required in the complete interval of time\n  #list_prod a vector of IDs of producers to be analyzed c('xhCWdtMAAAAJ', 'YirSp_cAAAAJ')\n  #mit_to_grw minimum share/production-value for a node to be considered as growing(emerging) area. This value should be less than min_to_dev and growing areas are > min_to_grw and < min_to_dev\n  #min_to_dev minimum share/production-value for a node to be considered as developed. -1 will be understood as mean of shares.\n  #dens_int number of intervals for density between 0.000001 and 1\n  #pl_min_dens the minimum density required to be presented/evaluated over the plot of the producer\n  #pl_node_sc a number that scales the size of the nodes\n  #pl_min_size minimum value for the size of the nodes\n  #pl_num_lab number of developed nodes to be labeled in the plot\n  #pred implies which is the transition to evaluate posible values are 'i_a', 'i_u', 'u_d' it uses initial for each state.\n  #what_eval rca, prop, ai what should the function evaluate to \n  #cum should the aggregation be accumulative since the very beginning. TRUE for positive\n  \n  #color palette <- INactive, Active, Growing, Advantage, Opportunity\n  #green palette\n  #color_palette <- c('#edf8e9', '#bae4b3', '#74c476', '#238b45','white','blue' )\n  #yellow-red heat palette \n  #color_palette <- c('#ededed', '#fecc5c', '#fd8d3c','#e31a1c', 'white', 'green')\n  color_palette <- c('#ededed', '#fecc5c', '#fd8d3c','#e31a1c', 'white', 'blue')\n  node.colors <- c(\"white\", rev(heat.colors(3)), \"white\") # from empty to developed 4 states\n  edge.colors <- c('#ededed', '#ededed', '#ededed', \"#bcbcbc\", \"#bcbcbc\" ) #from inactive, connecting active, connecting developed\n  frame.colors <- c('#ededed', '#ededed', '#ededed', \"#bcbcbc\",  \"black\") #from base, to recommended, to True Positive\n  agg_fun_name <-  as.character(quote(agg_fun))\n  #get sample of producers\n  data_interval <- load_data_interval(init = init, end = end, agg=NaN) #without aggregation\n  num_years <- end-init\n  #ensuring a minimum of publications min_prod per number of years in the interval of time\n  #data_interval <<- subset(data_interval, authorship_count > (num_years * min_prod)) #subset according number of authorships\n  #calculating totals \n  if(is.na(list_prod)[[1]])\n  {\n    #totals_producers <- aggregate(authorship_count~id_author , data_interval, FUN=sum)  \n    totals_producers <- aggregate(wgh_jfrac~id_author, data_interval, FUN=sum)  \n    #producers accomplish min production\n    #producers <- totals_producers$id_author[totals_producers$authorship_count> (num_years * min_prod)]\n    producers_ids <- totals_producers$id_author[totals_producers$wgh_jfrac> (num_years * min_prod)]\n    \n    if(n==-1)\n    {\n      n <- length(producers_ids)\n    }\n    #producers <- unique(data_interval[,1])\n    #print(paste(\"Number producers:\",length(producers)))\n    producers_sample <<- producers_ids[sample(length(producers_ids), n,replace = FALSE)]\n  }#end sampling producers\n  else\n  {\n    producers_sample <<- list_prod\n  }\n  \n  #print(paste(\"Number producers SAMPLE:\",length(producers_sample)))\n  \n  \n  \n  #get intervals\n  get_intervals_overlay(year_ini=init, year_fin=end,win=by)\n  \n  #data with only producers selected\n  data_sample <<- subset(data_interval, id_author %in% producers_sample)  #watch out with the name of the column of producers.\n  \n  #aggregating data for interval, producer, category, value, and calculating Shares, RCAs\n  data_to_use <- data.frame()\n  for(interval in intervals)\n  {\n    i <- match(interval, intervals) #index of parameter interval\n    if(cum == TRUE)\n      year_s <- init\n    else\n      year_s <- year_start[i]  \n    \n    year_e <- year_end[i] #simplify names #USING LOOONG AGGREGATION of time\n    data_int_raw <- subset(data_sample, year >= year_s & year <= year_e)\n    #data_int <- aggregate(x=data_int_raw['authorship_count'], by=list(id_author=data_int_raw$id_author, id_category = data_int_raw$subdiscipline_id), FUN=agg_fun)\n    data_int <- aggregate(x=data_int_raw['wgh_jfrac'], by=list(id_author=data_int_raw$id_author, id_category = data_int_raw$subdiscipline_id), FUN=agg_fun) #totalof production of a producer in a category\n    total_global <- sum(data_int$wgh_jfrac)\n    data_int <- data.frame(interval, data_int)\n    #data_prod_total <- aggregate(x=data_int['authorship_count'], by=list(id_author=data_int$id_author), FUN=sum)  #finding total production by producer\n    data_prod_total <- aggregate(x=data_int['wgh_jfrac'], by=list(id_author=data_int$id_author), FUN=sum)  #finding total production by producer\n    #print(data_prod_total)\n    data_int <- merge(data_int,data_prod_total, by='id_author') #adding total production to the table\n    #total per category\n       \n    #data_int['share'] <- data_int$authorship_count.x / data_int$authorship_count.y #computing shares\n    data_int['share'] <- data_int$wgh_jfrac.x / data_int$wgh_jfrac.y #computing shares\n    #aggregate\n    \n    data_categ_total <-  aggregate(x=data_int['wgh_jfrac.x'], by=list( id_category = data_int$id_category), FUN=agg_fun) #total of that category\n    data_int <- merge(data_int, data_categ_total, by='id_category')\n    data_int['total_global'] <- total_global\n    data_int['share_category'] <- data_int$wgh_jfrac.x.y / total_global\n    data_int['rca'] <- data_int$share/data_int$share_category\n    data_int['rca_bool'] <- data_int['rca']\n    data_int$rca_bool[data_int$rca_bool < 1] <- 0\n    data_int$rca_bool[data_int$rca_bool != 0] <- 1\n    \n    data_to_use <- rbind(data_to_use,data_int)\n    \n  }\n  data_to_use_copy <<- data_to_use\n  #________________________\n  \n  \n  #bring benchmark magp\n  #print(\"Loading Base Map\")\n  g_orig <- get_benchmark_map()\n  evaluation_data_total <- data.frame()   #to store final results\n  \n  for(producer in producers_sample)\n  {\n    for(interval in intervals)\n    {\n      #load data interval\n      i <- match(interval, intervals) #index of parameter interval \n      #year_s <- year_start[i]; year_e <- year_end[i] #USING NOT AGGREGATION of time\n      if(cum == TRUE)\n        year_s <- init\n      else\n        year_s <- year_start[i]  \n      \n      year_e <- year_end[i] #simplify names #USING LOOONG AGGREGATION of time\n      \n      #get original blank graph\n      g <- g_orig\n      data_producer <- data_to_use[data_to_use$id_author==producer & data_to_use$interval == interval,]\n      #defining first form options for nodes\n      V(g)$color <- node.colors[1]\n      V(g)$frame.color <- frame.colors[1]\n      V(g)$size <- pl_min_size\n      #V(g)$label_orig <- V(g)$label  #to export\n      V(g)$Label = as.character(nodes$subd_name[match(V(g)$name, nodes$Id)]) #watch out with the name of the column!!\n      V(g)$label <- ''\n      dev_nodes_flag <- FALSE\n      grw_nodes_flag <- FALSE\n      und_nodes_flag <- FALSE\n      V(g)$developed <- NA\n      V(g)$undeveloped <- NA\n      V(g)$growing <- NA\n      V(g)$density <- 0\n      active_nodes <- NA\n      grw_nodes <- NA\n      und_nodes <- NA\n      dev_nodes <- NA\n      sum_production <- NA\n      variety <- NA\n      measures <- NA\n      \n      #verify that info of producer for this time is not empty\n      if(nrow(data_producer)>0) \n      {\n        #ACTIVE NODES ---------------------------\n        active_nodes <- as.vector(data_producer[,'id_category']) #which areas are present in the data of the producer \n        nodes_info_act <- nodes[nodes$Id %in% active_nodes,]\n        nodes_info_act <- merge(nodes_info_act, data_producer, by.x='Id', by.y='id_category')\n        \n        #####ORDERING\n        active_nodes_g <- V(g)$name[V(g)$name %in% active_nodes] #TO GET THE order that provides iGraph\n        nodes_info_act <- nodes_info_act[match(active_nodes_g, nodes_info_act$Id),] #reordering\n        \n        #V(g)$color[V(g)$name %in% active_nodes] <- \"#cccccc\"\n        V(g)$color[V(g)$name %in% active_nodes] <- node.colors[2]\n        #print(V(g)$name[V(g)$name %in% active_nodes])\n        #print(nodes_info_act$Id)\n        #print(active_nodes)\n        \n        V(g)$value_eval[V(g)$name %in% active_nodes]<- as.numeric(nodes_info_act[,what_eval]) \n        \n        \n        #V(g)$shares_pl[V(g)$name %in% active_nodes]<- as.numeric(nodes_info_act[,what_eval]) \n        V(g)$shares_pl[V(g)$name %in% active_nodes]<- as.numeric(nodes_info_act[,'share']) \n        max_share_pl <- max(as.numeric(nodes_info_act[,what_eval]))\n        min_share_pl <- min(as.numeric(nodes_info_act[,what_eval]))\n        V(g)$size[V(g)$name %in% active_nodes] <- (((as.numeric(nodes_info_act[,what_eval]) - min_share_pl )/(max_share_pl-min_share_pl) )+pl_min_size) * pl_node_sc\n        V(g)$active <- 0\n        V(g)$inactive <- 1\n        V(g)$active[V(g)$name %in% active_nodes] <- 1\n        V(g)$inactive[V(g)$name %in% active_nodes] <- 0 #inactive means zero production\n        \n        V(g)$names_actives[V(g)$name %in% active_nodes] <- as.character(nodes_info_act$subd_name)\n        #V(g)$size[is.na(V(g)$size)] <- pl_min_size  #deliting size of \n       # vg_df_actives <<- as.data.frame(list( name=V(g)$name, shares=V(g)$shares, size=V(g)$size,names_actives=V(g)$names_actives,color= V(g)$color), stringsAsFactors = FALSE)\n        \n        #defining DEVELOPED nodes\n        cut_off_to_dev <- min_to_dev\n        cut_off_to_grw <- min_to_grw\n        quant_eval <- quantile(data_producer[,what_eval])\n        if(min_to_dev == -1)#if not defined value\n        {\n          #cut_off_to_dev <- mean(data_producer[,'share'])  #take the mean by default, useful for personal producers\n          cut_off_to_dev <- quant_eval[4]\n        }\n        dev_nodes_df <- data_producer[data_producer[what_eval]>= cut_off_to_dev,] #condition of development nodes\n        dev_nodes_df <- dev_nodes_df[order(dev_nodes_df[,what_eval], decreasing = TRUE),] #ordering for what eval\n        \n        if(min_to_grw == -1) #if default value\n        {\n          cut_off_to_grw <- quant_eval[2]\n        }\n        grw_nodes_df <- data_producer[data_producer[what_eval]>= cut_off_to_grw & data_producer[what_eval] < cut_off_to_dev,] #grwoing nodes\n        und_nodes_df <- data_producer[data_producer[what_eval]< cut_off_to_grw,] #undeveloped nodes\n        #print(\"hjere\")\n        #print(und_nodes_df)\n        #print(\"Sum shares\")\n        #print(sum(data_producer['share']))\n        #print(\"Dev nodes DF\")\n        #print(dev_nodes_df)\n        #print(\"Data_Producer\")\n        #print(data_producer)\n        if(nrow(und_nodes_df)>0)\n        {\n          und_nodes <- as.vector(und_nodes_df[,'id_category'])\n          und_nodes_flag <- TRUE\n          nodes_info_und <- nodes[nodes$Id %in% und_nodes,]\n          nodes_info_und <- merge(nodes_info_und, data_producer, by.x='Id', by.y='id_category')\n          #ordering\n          und_nodes_g <- V(g)$name[V(g)$name %in% und_nodes]\n          nodes_info_und <- nodes_info_und[match(und_nodes_g, nodes_info_und$Id), ]\n          V(g)$undeveloped <- NA #only active nodes could be evaluated\n          V(g)$undeveloped[V(g)$name %in% active_nodes] <- 0 #only active nodes could be evaluated\n          V(g)$undeveloped[(V(g)$name %in% und_nodes)] <- 1 #is it UNoccupied\n        }\n        if(nrow(grw_nodes_df)>0)\n        {\n          grw_nodes <- as.vector(grw_nodes_df[,'id_category'])\n          grw_nodes_flag <- TRUE\n          nodes_info_grw <- nodes[nodes$Id %in% grw_nodes,]\n          nodes_info_grw <- merge(nodes_info_grw, data_producer, by.x='Id', by.y='id_category')\n          #ordering\n          grw_nodes_g <- V(g)$name[V(g)$name %in% grw_nodes]\n          nodes_info_grw <- nodes_info_grw[match(grw_nodes_g, nodes_info_grw$Id),] #reordering\n          V(g)$color[V(g)$name %in% grw_nodes] <- node.colors[3]\n          V(g)$growing <- NA\n          V(g)$growing[V(g)$name %in% active_nodes] <- 0\n          V(g)$growing[V(g)$name %in% grw_nodes] <- 1\n        }\n        if(nrow(dev_nodes_df)>0)\n        {\n          dev_nodes <- as.vector(dev_nodes_df[,'id_category'])\n          dev_nodes_lab <- as.vector(dev_nodes_df[1:pl_num_lab, 'id_category']) #supossing it is ordered by shares\n          \n          dev_nodes_flag <- TRUE\n          nodes_info_dev <- nodes[nodes$Id %in% dev_nodes,]\n          nodes_info_dev <- merge(nodes_info_dev, data_producer, by.x='Id', by.y='id_category')\n          #ordering\n          dev_nodes_g <- V(g)$name[V(g)$name %in% dev_nodes] #TO GET THE order that provides iGraph\n          dev_nodes_lab_g <- V(g)$name[V(g)$name %in% dev_nodes_lab]\n          \n          nodes_info_dev <- nodes_info_dev[match(dev_nodes_g, nodes_info_dev$Id),] #reordering\n          nodes_info_dev_lab <- nodes_info_dev[match(dev_nodes_lab_g, nodes_info_dev$Id), ]\n          #V(g)$label[V(g)$name %in% dev_nodes] <-\" \"          \n          V(g)$label[V(g)$name %in% dev_nodes_lab ] <- as.character(nodes_info_dev_lab[,'subd_name'])\n          V(g)$color[V(g)$name %in% dev_nodes] <-node.colors[4]\n          \n          V(g)$developed <- NA #only active nodes could be evaluated\n          V(g)$developed[V(g)$name %in% active_nodes] <- 0 #only active nodes could be evaluated\n          V(g)$developed[V(g)$name %in% dev_nodes] <- 1 #is it occupied\n          \n          #vg_df_dev <<- as.data.frame(list( name=V(g)$name, shares=V(g)$shares,developed=V(g)$developed, size=V(g)$size,label=V(g)$label,names_actives=V(g)$names_actives,color= V(g)$color), stringsAsFactors = FALSE)   \n        }\n        #defining actual state \n        #print(\"dev nodes vector\")\n        #print(dev_nodes)\n        #print(\"grw nodes vector\")\n        #print(grw_nodes)\n        #print(\"und nodes vector\")\n        #print(und_nodes)\n        #print(paste(\"Cut off growing\", cut_off_to_grw, \"Cut off to dev\", cut_off_to_dev))\n        \n        \n        num_act <- length(na.omit(active_nodes)) #any production \n        num_dev <- length(na.omit(dev_nodes)) #developed area\n        num_grw <- length(na.omit(grw_nodes)) #growing area\n        num_und <- length(na.omit(und_nodes)) #underdeveloped area \n        num_ina <- vcount(g)-num_act\n        \n        #measures <- paste('Local Variety: ', as.character(variety), 'Sum Prod', as.character(data_producer$total_prod))\n        #measures <- paste('Active:', as.character(num_act), 'Undeveloped',as.character(num_und),'Growing:', as.character(num_grw),'Developed: ', as.character(num_dev))\n        measures <- paste('Undeveloped <', round(cut_off_to_grw,4),  '< Growing Areas <', round(cut_off_to_dev,4), 'Developed Areas', '\\n')\n        #V(g)$sum_prox <- sum(E(g)$weight[E(g)[ from (ver) ]])\n      }#end no data production\n      else\n      {\n        #DEFINE ZERO for a period without data, this is needed because otherwise it is impossible to plot the graph\n        print(paste(\"NO DATA HERE!! For producer:\", producer, \"INterval:\", interval))\n        #         V(g)$size <- 0\n        #         V(g)$label <- NA\n        #         V(g)$developed <- NA\n        #         V(g)$density <- 0\n        #         active_nodes <- NA\n        #         sum_production <- NA\n        #         variety <- NA\n        #         measures <- NA\n      }\n      \n      #measuring density\n      V(g)$sum_prox <- graph.strength(g) #weighted degree used to calculate densities \n      \n      \n      #which are the nodes you want to asume as active or developed.\n      for(pred in c('act', 'dev')) #activation or developing\n      {\n        E(g)$weight_bool <- 0\n        if(pred == 'act')\n        {\n          V(g)$dev_temp <- V(g)$active\t\n          #print(paste(\"Sum Act Temp\"))\n          #print(sum(V(g)$dev_temp))\n          #print(V(g)$dev_temp)\n        }\n        if(pred=='dev')\n        {\n          V(g)$dev_temp <- V(g)$developed\t\n          V(g)$dev_temp[is.na(V(g)$dev_temp)] <- 0\n          #print(paste(\"Sum DEV Temp\"))\n          #print(sum(V(g)$dev_temp))\n          #print(V(g)$dev_temp)\n        }\n      \n          #V(g)$dev_temp[is.na(V(g)$dev_temp)] <- 0\n          E(g)$weight_bool[ E(g)[from (V(g)$name[V(g)$dev_temp ==1 ])] ] <- 1 #make 0 those edges that are not connecting occupaid nodes, and 1 those edges connected to nodes active. NOTE that, by using this technnique,for active nodes, density will be 1\n          #print(paste(\"LINKS IN \", pred))\n          #print(sum(E(g)$weight_bool))\n        \n          E(g)$weight_occ <- E(g)$weight * E(g)$weight_bool #copy weight for active links\n          V(g)$sum_prox_occ <- graph.strength(g,weights=E(g)$weight_occ)  #\n          if(pred =='act')\n          {\n            V(g)$dens_act <- V(g)$sum_prox_occ/V(g)$sum_prox  #densities\n            V(g)$dens_act[V(g)$name %in% dev_nodes] <- 0  #cleanning density of active nodes that is 1.\n          }\n          if(pred =='dev')\n          { \n            V(g)$dens_dev <- V(g)$sum_prox_occ/V(g)$sum_prox  #densities\n            V(g)$dens_dev[V(g)$name %in% dev_nodes] <- 0  #cleanning density of developed nodes that is 1.\n          }\n          \n         #defining boolean values 1 True, 0 False, for each possible state of the nodes\n          \n          #V(g)$inactive <- 0\n          #V(g)$inactive[V(g)$occupied != 1] <- 1\n          #V(g)$active <- V(g)$occupied\n          \n          #V(g)$recom_0 <- 0 #moved to density variable\n          #V(g)$recom_0[V(g)$density > pl_min_dens] <- 1 #here we can manage a differnet value to recommed \n          #V(g)$not_recom_0 <- 1  #not recommended or classified as Negatives\n          #V(g)$not_recom_0[V(g)$density > pl_min_dens] <- 0\n      }#end for type of prediction    \n      evaluation<-''\n      \n      if(i > 1) #there is a previous state\n      {\n        #defining states transition means that became developed\n        V(g)$ts_dragons <- V(g_prev)$inactive * V(g)$inactive\n        V(g)$ts_introduction <- V(g_prev)$inactive * V(g)$undeveloped\n        V(g)$ts_growth <- V(g_prev)$undeveloped * V(g)$growing\n        \n        V(g)$ts_decline <- V(g_prev)$developed * V(g)$undeveloped\n        #totally binary from inactive to active\n        V(g)$ts_activated <- V(g_prev)$inactive * V(g)$active\n        V(g)$ts_transition <- V(g_prev)$undeveloped * V(g)$developed\n        V(g)$ts_maturity <- V(g_prev)$growing * V(g)$developed\n        \n        #print(\"values..\")\n        #verify_g<<- data.frame(V(g)$occupied, V(g)$name, V(g)$label,V(g)$active, V(g_prev)$active, V(g_prev)$inactive, V(g)$st_transition)#\n        prev_interval <- intervals[i-1]\n        #evaluation_roc <- data.frame(producer, prev_interval, interval, V(g)$name, V(g)$Label, V(g_prev)$active,  V(g_prev)$inactive,  V(g_prev)$undeveloped, V(g_prev)$growing, V(g_prev)$developed, V(g)$inactive, V(g)$active, V(g)$undeveloped, V(g)$growing,V(g)$developed, V(g)$ts_dragons, V(g)$ts_introduction,V(g)$ts_growth,V(g)$ts_maturity ,V(g)$ts_decline, V(g)$ts_activated, V(g)$ts_transition )#\n        evaluation_roc <- data.frame(what_eval, producer, prev_interval, V(g_prev)$value_eval, V(g_prev)$dens_act, V(g_prev)$dens_dev, interval, V(g)$value_eval, V(g)$name, V(g)$Label, V(g_prev)$active,  V(g)$active, V(g)$ts_activated, V(g_prev)$undeveloped, V(g)$developed, V(g)$ts_transition, V(g_prev)$growing, V(g)$developed, V(g)$ts_maturity) #\n        \n          #print(evaluation_data)\n          evaluation_data_total <- rbind(evaluation_data_total, evaluation_roc)\n        #print(paste(\"interval:\", i, \"  Added user:\", producer))\n        #label for plot\n       \n        \n        #print(v_g)\n        num_dragons <- length(V(g)$ts_dragons[V(g)$ts_dragons==1 & !is.na(V(g)$ts_dragons)])\n        num_introduction <-  length(V(g)$ts_introduction[V(g)$ts_introduction==1 & !is.na(V(g)$ts_introduction)])\n        num_growth <-  length(V(g)$ts_growth[V(g)$ts_growth==1 & !is.na(V(g)$ts_growth)])\n        num_maturity <-  length(V(g)$ts_maturity[V(g)$ts_maturity==1 & !is.na(V(g)$ts_maturity)])\n        num_decline <- length(V(g)$ts_decline[V(g)$ts_decline==1 & !is.na(V(g)$ts_decline)] )\n        num_activated <- length(V(g)$ts_activated[V(g)$ts_activated==1 & !is.na(V(g)$ts_activated)] )\n        num_transition <- length(V(g)$ts_transition[V(g)$ts_transition==1 & !is.na(V(g)$ts_transition)] )\n\n        #evaluation <- paste(\"Transition nodes (green circled): \", as.character(num_transition))\n          \n   \n       \n      }#end loop i >1 means state with a previous state to evaluate\n      \n      if(pl==TRUE)\n      {\n        #ploting\n        #adding labels to nodes\n        active_nodes_density_lab <- V(g)$name[V(g)$dens_dev>0] #nodes that you have to LABEL becausse of the density.\n        nodes_info_density <- nodes[nodes$Id %in% active_nodes_density_lab,]\n        \n        #V(g)$label[V(g)$name %in% active_nodes_density_lab] <- paste(strtrim(nodes_info_density$subd_name,5), as.character(round(V(g)$density[V(g)$name %in% active_nodes_density_lab],2))) #label with name and value of density\n        #V(g)$label[V(g)$name %in% active_nodes_density_lab] <- paste( as.character(round(V(g)$density[V(g)$name %in% active_nodes_density_lab],2))) #label with name and value of density\n        \n        #V(g)$size[V(g)$name %in% active_nodes_density_lab] <- V(g)$density[V(g)$name %in% active_nodes_density_lab] #size of recommended nodes, according density\n        #V(g)$size[V(g)$name %in% active_nodes_density_lab] <- pl_min_size\n        #create instead a color map from white to black for recommended values according to density\n        #density_nodes_g <- V(g)$name[V(g)$name %in% active_nodes_density_lab] #TO GET THE order that provides iGraph\n        #nodes_info_act <- nodes_info_act[match(active_nodes_g, nodes_info_act$Id),] #reordering\n        \n        #V(g)$color[V(g)$name %in% active_nodes_density_lab] <- color_palette[5]\n        V(g)$frame.color[V(g)$name %in% active_nodes_density_lab] <- frame.colors[5] #color_palette[6]\n        #V(g)$color[V(g)$name %in% active_nodes_density_lab] <- node.colors[5] #color_palette[6]\n        \n        #MUST USE AS.CHARACTER, OTHERWISE it will take an integer resulting in extrange colors\n        #V(g)$color[V(g)$name %in% active_nodes_density_lab] <- as.character(nodes_info_density$color)\n        num_rcm <- length(active_nodes_density_lab)\n        densities <- \"\"\n        #densities <- paste(\"Transition:\" ,\"Undeveloped to Developed.\",\" Recommended nodes (connected to developed nodes) for the next period (dark gray):\",as.character(num_rcm))\n        measures <- paste(measures,densities, sep=\"  \")\n        \n        #edges\n        E(g)$color <- edge.colors[2] #coloring edges connecting active nodes\n        if(dev_nodes_flag==TRUE)\n        {\n          #labeling all edges from recommended nodes\n          #E(g)$label[ E(g)[from (V(g)[V(g)$density>pl_min_dens]) ] ] <-  E(g)$weight[ E(g)[from (V(g)[V(g)$density>pl_min_dens]) ] ] #bug here, something happen \n          #print(\"CACCA...\")\n          #print(V(g)[V(g)$density>0])\n          #print(E(g)[from (V(g)[V(g)$density>0]) ])\n          #print(E(g)$label[ E(g)[from (V(g)[V(g)$density>0]) ] ])\n          #coloring same edges\n          #E(g)$label.color[ E(g)[from (V(g)[V(g)$density>pl_min_dens]) ] ] <- \"#aaaaaa\" #color labels of links connecting recommended node\n          E(g)$color[E(g)$weight_bool==1] <- edge.colors[4] #coloring edges connecting active nodes\n          #E(g)$label[E(g)$weight_bool==1] <- E(g)$weight[E(g)$weight_bool==1] #adding label to nodes connecting active nodes or recommended nodes\n          #E(g)$label.color[E(g)$weight_bool==1] <- \"#111111\" #edges to consider as potential links of emerging\n        }\n        \n        #titles\n        prod_name <- as.character(producers$name[producers$id==producer])\n        prod_domain <- as.character(producers$i.domain[producers$id==producer])\n        title <- paste( prod_name,\" \", year_s,'-',year_e, '\\nBase Map: ', taxo, ' - Overlay Data: ', dataset, \" - Evaluating: \", toupper(what_eval),sep=\"\")\n        file_name <- paste('OverlayMap', taxo, prod_domain, year_s,year_e, what_eval, sep='_')\n        #subtitle <- paste('Layout: Frughtermand Rengold', '| Size: Share of authorships', '| Color: Areas of Science (original colors) \\n' , measures, '\\n', evaluation)\n        subtitle <- paste('Layout: Fruchterman–Reingold', '| Size: Share of authorships', '| Color: Values of ', toupper(what_eval), \" \\n Agg. function: \", \"sum\", '\\n' , measures)\n        #exporting graph to a dataframe\n        #V(g)$cut_off_to_dev <- cut_off_to_dev\n        #vg_final<<- data.frame(  V(g)$name, V(g)$label, V(g)$color, V(g)$active,V(g)$inactive,V(g)$size, V(g)$shares, V(g)$cut_off_to_dev, V(g)$developed, V(g)$undeveloped )#\n        par(lend = 1)           # square line ends for the color legend\n        legend = c(paste(\"Inactive\", num_ina), paste(\"Undeveloped\", num_und), paste(\"Growing\", num_grw), paste(\"Developed\", num_dev), paste(\"Opportunity\", num_rcm)) # category labels   \n        plot_graph_overlay(g, layout='fr', title = title , subtitle=subtitle, file_name=file_name, legend=legend, l_pt.bg=node.colors, l_col=frame.colors )\n        \n        \n        \n        #print(g)\n      }#end plotting\n      \n      \n      #save for next iteration\n      g_prev <- g\n      prev_num_act <- num_act\n    }#end interval\n    \n  }#end producers\n  \n  #evaluating data of \n  #print(evaluation_data_total)\n  #str(evaluation_data_total)\n  file_n <- file.path(path_interval_overlay,paste(\"DATA_EVALUATION_ROC\",interval_label,\"min_prod\",min_prod,\"samp\",n, \"trans\", pred, \".csv\"))\n  write.csv(x=evaluation_data_total, file=file_n, row.names=FALSE)\n  #print(paste(\"wrote file\", file_n ))\n  data_eval_roc <<- evaluation_data_total\n}\n\n\n\n#evaluate roc curves\n#evaluate roc for each producer\nplot_rocs <- function()\n{\n  require(MESS) #getting area under the curve\n  \n  intervals_pred <- unique(data_eval_roc$interval)\n  pred <- 'kk'\n  data_eval_roc_act <- data.frame()\n  \n  for(prod in unique(data_eval_roc$producer))\n  {\n    for(inter in intervals_pred)\n    {\n      #analyzing ROC curves\n      #print(prod)\n      #print(inter)\n      data_eval_prod <- subset(data_eval_roc, producer==prod & interval==inter)\n      data_prev_inactive <- subset(data_eval_prod, V.g_prev..active==0)\n      #print(nrow(data_prev_inactive))\n      if(nrow(data_prev_inactive)==0) #no previous InActive data\n      {\n        print(paste(\"producer:\" , prod, \"Has no previous INactive data in interval\", inter))\n      }\n      else\n      {\n        data_eval_sor <- data_prev_inactive[order(-data_prev_inactive$V.g_prev..dens_act),]\n        data_eval_roc_act <- rbind(data_eval_roc_act, data_eval_sor)  #aggregate to see data used to evaluate\n        plot_roc_interval(data_eval_sor, positive=\"V.g..active\", trans=\"Inactive to Active\", col='brown')\n      }#end else no data\n      \n      \n      \n      ##############EVALUATING GROWING  TO  DEVELOPED\n      data_prev_growing <- subset(data_eval_prod, V.g_prev..growing==1)\n      if(nrow(data_prev_growing)==0) #no previous InActive data\n      {\n        print(paste(\"producer:\" , prod, \"Has no previous UNDEVELOPED data in interval\", inter))\n      }\n      else\n      {\n        data_eval_sor <- data_prev_growing[order(data_prev_growing$V.g_prev..dens_dev),]\n        data_eval_roc_act <- rbind(data_eval_roc_act, data_eval_sor)  #aggregate to see data used to evaluate\n        plot_roc_interval(data_eval_sor, positive=\"V.g..developed\", trans=\"Growing to Developed\", col='orange')\n        \n      }#end else No previous data\n      \n      \n        ##############EVALUATING UNDEV TO  DEVELOPED \n      data_prev_undeveloped <- subset(data_eval_prod, V.g_prev..undeveloped==1)\n      if(nrow(data_prev_undeveloped)==0) #no previous InActive data\n      {\n        print(paste(\"producer:\" , prod, \"Has no previous UNDEVELOPED data in interval\", inter))\n      }\n      else\n      {\n      data_eval_sor <- data_prev_undeveloped[order(data_prev_undeveloped$V.g_prev..dens_dev),]\n      data_eval_roc_act <- rbind(data_eval_roc_act, data_eval_sor)  #aggregate to see data used to evaluate\n      plot_roc_interval(data_eval_sor, positive=\"V.g..developed\", trans=\"Undeveloped to Developed\")\n        \n      }#end else No previous data\n      \t\n    }#end for interval\n  }#end for producer\n  data_eval_roc_used <<- data_eval_roc_act\n}\n\n#ploting ROC curves for density evaluatio\nplot_roc_interval <- function(data_eval_sor, positive, trans=\"\", col=\"skyblue\"  )\n{\n  #print(\"HEEEYYYY\")\n  prev_interval <- data_eval_sor$prev_interval[1]\n  interval <- data_eval_sor$interval[1]\n  prod <- as.character(droplevels(data_eval_sor$producer[[1]]))\n  what_eval <- data_eval_sor$what_eval[1]\n  \n  #changing NA per 0\n  data_eval_sor[, positive][is.na(data_eval_sor[, positive])] <- 0\n  \n  if(sum(!data_eval_sor[,positive], na.rm=TRUE) != 0 && sum(data_eval_sor[,positive], na.rm=TRUE)!= 0 )\n  {\n    x <- cumsum(!data_eval_sor[,positive]) / sum(!data_eval_sor[,positive], na.rm=TRUE)\n    y <- cumsum(data_eval_sor[,positive]) / sum(data_eval_sor[,positive], na.rm=TRUE)\n   #print(cumsum(!data_eval_sor[,positive]))\n   #print(cumsum(data_eval_sor[,positive]))\n    \n    plot(x, y, \n      main=paste(get_prod_name(prod),  trans, toupper(what_eval), sep=\"  |  \"), \n      sub=paste(\" From: \", prev_interval, \"To:\", interval),\n      xlab=\"False Positives\",\n      ylab = \"True Positives\",\n      col = col\n    )\n    #print(paste(x,y))\n    auc_val <- auc(x,y, type = 'spline')\n    #text(0.8,0.2, paste(\"AUC=\",round(auc_val,3)))\n    #text(0.8,0.1, paste(\"N to EVAL=\", nrow(data_eval_sor)))\n    #text(0.8,0.0, paste(\"TP= \", sum(data_eval_sor[,positive])))\n    \n    legend(\"right\", \n      legend=c(paste(\"AUC=\",round(auc_val,3)), paste(\"N to EVAL=\", nrow(data_eval_sor)),  paste(\"TP= \", sum(data_eval_sor[,positive]))),\n      cex=0.8\n    )\n    #print(paste(\"AUC\", auc_val))\n    \n  }   \n  else\n  {\n    print(paste(\"No possible evaluation for\", prod, \" In interval \", interval, \" Transition\", trans))\n  }\n     \n}",
    "created" : 1447615652097.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "685894892",
    "id" : "DA4C14CB",
    "lastKnownWriteTime" : 1448288610,
    "path" : "~/Dropbox/doctorado/MIT_PROJECT/TESIS_RESEARCH_SPACE/CODES/RS2015/ROC-2015.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "type" : "r_source"
}